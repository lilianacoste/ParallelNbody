import numpy as np
import matplotlib.pyplot as plt

def read_simulation_output(file_path):
    """
    Reads the output from the simulation generated by the C++ code.
    Assumes the format is tab-separated values with each time step on a new line.
    """
    data = []
    with open(file_path, 'r') as f:
        for line in f:
            values = line.strip().split('\t')
            if len(values) == 12:  # Check if the line contains data for one particle
                data.append([float(v) for v in values[1:]] )  # Skip the first value, which is nbpart
    return np.array(data)

def plot_positions(data, num_steps, num_particles, output_filename="simulation.png"):
    """
    Plots the positions of the particles over the time steps.
    """
    fig, ax = plt.subplots()
    
    for step in range(0, num_steps, 10):  # Change the step interval for plotting frequency
        positions = data[step, :, 1:4]  # Extract positions (x, y, z) for all particles
        ax.scatter(positions[:, 0], positions[:, 1], label=f"Step {step}")
    
    ax.set_xlabel('X Position')
    ax.set_ylabel('Y Position')
    ax.set_title('Particle Positions Over Time')
    ax.legend()
    plt.savefig(output_filename)
    plt.show()

def main():
    # File containing the output from your C++ simulation (e.g., "simulation_output.txt")
    file_path = 'simulation_output.txt'
    num_steps = 100  # Total number of steps to process
    num_particles = 10  # Number of particles in the simulation
    
    # Read the simulation output
    data = read_simulation_output(file_path)
    
    # Reshape the data to have a time axis
    data = data.reshape(num_steps, num_particles, -1)  # Reshape to (steps, particles, values)
    
    # Plot the positions of the particles
    plot_positions(data, num_steps, num_particles)

if __name__ == "__main__":
    main()
